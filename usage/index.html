<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Usage Guide · DeformationPaths.jl</title><meta name="title" content="Usage Guide · DeformationPaths.jl"/><meta property="og:title" content="Usage Guide · DeformationPaths.jl"/><meta property="twitter:title" content="Usage Guide · DeformationPaths.jl"/><meta name="description" content="Documentation for DeformationPaths.jl."/><meta property="og:description" content="Documentation for DeformationPaths.jl."/><meta property="twitter:description" content="Documentation for DeformationPaths.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/custom.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">DeformationPaths.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Usage Guide</a><ul class="internal"><li><a class="tocitem" href="#Installation"><span>Installation</span></a></li><li><a class="tocitem" href="#Usage"><span>Usage</span></a></li><li><a class="tocitem" href="#Exported-functions"><span>Exported functions</span></a></li></ul></li><li><span class="tocitem">API Reference</span><ul><li><a class="tocitem" href="../DeformationPath/">DeformationPath</a></li><li><a class="tocitem" href="../ConstraintSystems/">ConstraintSystem</a></li><li><a class="tocitem" href="../Visualization/">Visualization</a></li><li><a class="tocitem" href="../Auxiliary/">Auxiliary Methods</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Usage Guide</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Usage Guide</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/matthiashimmelmann/DeformationPaths.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/matthiashimmelmann/DeformationPaths.jl/blob/master/docs/src/usage.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Guide-for-Using-the-package-DeformationPaths.jl"><a class="docs-heading-anchor" href="#Guide-for-Using-the-package-DeformationPaths.jl">Guide for Using the package DeformationPaths.jl</a><a id="Guide-for-Using-the-package-DeformationPaths.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Guide-for-Using-the-package-DeformationPaths.jl" title="Permalink"></a></h1><p>This package allows the approximation of deformation paths corresponding to a variety of geometric constraint systems. To accomplish this, we iteratively apply a combination of Euler predictor steps and Gauss-Newton corrector steps to take a local stpe on the constraint set. This approach is known as homotopy continuation. </p><h2 id="Installation"><a class="docs-heading-anchor" href="#Installation">Installation</a><a id="Installation-1"></a><a class="docs-heading-anchor-permalink" href="#Installation" title="Permalink"></a></h2><pre><code class="nohighlight hljs">julia&gt; ]
(@v1.10) pkg&gt; add DeformationPaths</code></pre><h2 id="Usage"><a class="docs-heading-anchor" href="#Usage">Usage</a><a id="Usage-1"></a><a class="docs-heading-anchor-permalink" href="#Usage" title="Permalink"></a></h2><pre><code class="language-julia hljs">using DeformationPaths</code></pre><h3 id="Bar-and-Joint-Frameworks"><a class="docs-heading-anchor" href="#Bar-and-Joint-Frameworks">Bar-and-Joint Frameworks</a><a id="Bar-and-Joint-Frameworks-1"></a><a class="docs-heading-anchor-permalink" href="#Bar-and-Joint-Frameworks" title="Permalink"></a></h3><p>Bar-and-Joint frameworks are given by embedded graphs whose edges are equipped with Euclidean distance constraints. We can create a deformation path using the constructor <code>DeformationPath</code>. For example, a deformation path starting in a realization of the complete bipartite graph <span>$K_{2,4}$</span> (giving rise to a <code>Framework</code>) can be computed using the following code. For instance, we can generate the framework on a list of edges and a realization given by a matrix. Here, vertex <code>i</code> corresponds to the <code>i</code>-th column in the matrix.</p><pre><code class="language-julia hljs">F = Framework([[1,3],[1,4],[1,5],[1,6],[2,3],[2,4],[2,5],[2,6]], Matrix([0 0; 0 1; 1 -1; 1 0; 1 1; 1 2]&#39;))
D = DeformationPath(F, [1], 500; step_size=0.025)
animate(D,F,&quot;completebipartite_motion&quot;)</code></pre><video controls="controls" width="100%" height="auto" style="max-width: 850px;">
  <source src="/DeformationPaths.jl/assets/completebipartite_motion.mp4" type="video/mp4">
  Your browser does not support the video tag.
</video><p>There is only a single infinitesimal motion, which we select via setting <code>flex_mult=[1]</code>. This input selects the initial tangent vector <span>$\sum_{i=1}^r c_i \mathbf{q}_i$</span> for a basis <span>$(\mathbf{q}_1,\dots,\mathbf{q}_r)$</span> of nontrivial infinitesimal flexes. We compute <code>500</code> predictor corrector steps with a step size of <code>0.025</code> and save the resulting animation under the file name <code>&quot;completebipartite_motion.png&quot;</code> using the method <code>animate</code>.</p><p>We can also pin vertices in the framework, which are depicted as triangles. This is exemplified through the following animation of the cuspidal double Watt mechanism:</p><pre><code class="language-julia hljs">F = Framework([[1,2],[2,3],[2,4],[3,9],[3,4],[3,5],[4,5],[5,6],[6,7],[7,8],[7,9],[8,9],[8,10],[9,10],[10,11]], Matrix([0 0; 1 0; 2 1; 1 2; 3 2; 4 2; 5 2; 7 2; 6 1; 7 0; 8 0;]&#39;); pinned_vertices=[1,6,11])
D = DeformationPath(F, [], 500; step_size=0.05)
animate(D,F,&quot;double_watt_motion&quot;; padding=0.35, fixed_pair=(1,6), fixed_direction=[4,2])</code></pre><video controls="controls" width="100%" height="auto" style="max-width: 850px;">
  <source src="/DeformationPaths.jl/assets/double_watt_motion.mp4" type="video/mp4">
  Your browser does not support the video tag.
</video><p>By setting <code>flex_mult</code> to be an empty array <code>[]</code>, we tell the program to automatically select the flex given by the sum of the basis vectors of the nontrivial infinitesimal flex space at the starting configuration. </p><p>Remarkably, this mechanism has a cusp singularity that the deformation path approximation algorithm manages to accurately traverse via an acceleration-based direction-detection method. Moreover, this is a stressed framework, for which typically Newton&#39;s method does not converge well; our choice of implementation for Newton&#39;s method does not have this problem.</p><h3 id="Frameworks-on-Surfaces"><a class="docs-heading-anchor" href="#Frameworks-on-Surfaces">Frameworks on Surfaces</a><a id="Frameworks-on-Surfaces-1"></a><a class="docs-heading-anchor-permalink" href="#Frameworks-on-Surfaces" title="Permalink"></a></h3><p>Constraining a bar-and-joint frameworks&#39; vertices to a surface provides an important and well-studied restriction. In the <code>FrameworkOnSurface</code> constructor, the underlying surface is provided as an implicit function in the method&#39;s third argument. The following example provides a motion of a framework on a 4-cycle graph that is constrained to the one hyperboloid.</p><pre><code class="language-julia hljs">F = FrameworkOnSurface([[1,2],[2,3],[3,4],[1,4]], Matrix([-sqrt(1/2) -sqrt(1/2) -1; -1 0 0; 0 1 0; sqrt(1/2) sqrt(1/2) 1]&#39;), x-&gt;x[1]^2+x[2]^2-x[3]^2-1)
D = DeformationPath(F, [1,1], 350; step_size=0.035)
animate(D,F,&quot;squareonhyperboloid_motion&quot;; animate_rotation=true, filetype=&quot;mp4&quot;)</code></pre><video controls="controls" width="100%" height="auto" style="max-width: 850px;">
  <source src="/DeformationPaths.jl/assets/squareonhyperboloid_motion.mp4" type="video/mp4">
  Your browser does not support the video tag.
</video><h3 id="Angle-Constrained-Frameworks"><a class="docs-heading-anchor" href="#Angle-Constrained-Frameworks">Angle-Constrained Frameworks</a><a id="Angle-Constrained-Frameworks-1"></a><a class="docs-heading-anchor-permalink" href="#Angle-Constrained-Frameworks" title="Permalink"></a></h3><p>Beyond bar-joint frameworks, angle-constrained frameworks are popular objects of study in rigidity theory. These objects come with sequences of three vertices, whose interior angle is constrained to be constant, and can be created using the command <code>AngularFramework</code>. We provide a visual representation of Thales&#39; Theorem as an example:</p><pre><code class="language-julia hljs">F = AngularFramework([[1,3,2]], Matrix([-1 0; 1 0; -sqrt(1/2) sqrt(1/2);]&#39;); pinned_vertices=[1,2])
D = DeformationPath(F, [1], 250; step_size=0.025)
animate(D,F,&quot;thales_motion&quot;; padding=0.075, pin_point_offset=0.075, filetype=&quot;mp4&quot;)</code></pre><video controls="controls" width="100%" height="auto" style="max-width: 850px;">
  <source src="/DeformationPaths.jl/assets/thales_motion.mp4" type="video/mp4">
  Your browser does not support the video tag.
</video><h3 id="Sticky-Sphere-Packings"><a class="docs-heading-anchor" href="#Sticky-Sphere-Packings">Sticky Sphere Packings</a><a id="Sticky-Sphere-Packings-1"></a><a class="docs-heading-anchor-permalink" href="#Sticky-Sphere-Packings" title="Permalink"></a></h3><p>Sphere packings are given by a non-overlapping arrangements of spheres with fixed radii in <span>$\mathbb{R}^2$</span>. They are called sticky, when existing contacts cannot be broken. In this package, spheres that form a contact during the deformation path computation remain in contact. The <code>SpherePacking</code> class takes a list of radii and a realization as input. As the optional parameter <code>pinned_vertices</code>, we can specify which vertices in the disk packings should be pinned. As an example, we can create an animation using the following code:</p><pre><code class="language-julia hljs">F = SpherePacking([1.,1.,1.,1.], Matrix([0 0; 1.75 -sqrt(2^2-(1.75)^2); 3.5 0; 4.5 sqrt(3)]&#39;); pinned_vertices=[1])
D = DeformationPath(F, [1,1], 250; step_size=0.025)
animate(D,F,&quot;diskpacking_motion&quot;)</code></pre><video controls="controls" width="100%" height="auto" style="max-width: 850px;">
  <source src="/DeformationPaths.jl/assets/diskpacking_motion.mp4" type="video/mp4">
  Your browser does not support the video tag.
</video><p>This construction also works in 3D, as demonstrated by the following code:</p><pre><code class="language-julia hljs">F = SpherePacking([1.,1.,1.,1.], Matrix([0 0 0; 2 0 0; 0 2 0; 0 0 2]&#39;), pinned_vertices = [1,2])
D = DeformationPath(F, [1,1,1], 500; step_size=0.04)
animate(D,F,&quot;spherepacking_motion&quot;; filetype=&quot;mp4&quot;)</code></pre><video controls="controls" width="100%" height="auto" style="max-width: 850px;">
  <source src="/DeformationPaths.jl/assets/spherepacking_motion.mp4" type="video/mp4">
  Your browser does not support the video tag.
</video><h3 id="Body-Hinge-Frameworks"><a class="docs-heading-anchor" href="#Body-Hinge-Frameworks">Body-Hinge Frameworks</a><a id="Body-Hinge-Frameworks-1"></a><a class="docs-heading-anchor-permalink" href="#Body-Hinge-Frameworks" title="Permalink"></a></h3><p>Body-hinge frameworks are composed of rigid bodies – think of polygonal faces that are not allowed to shift shapes – that are joined along edges. Therefore, bodies are allowed to rotate around edges, comparable to a hinge. Such an object can be created using the <code>BodyHinge</code> constructor. The following example creates a flexible pyramid with a pentagonal face:</p><pre><code class="language-julia hljs">F = BodyHinge([[1,2,3],[1,3,4],[1,4,5],[1,5,6],[1,6,2]], Matrix([0 0 1; cos(2*pi/5) sin(2*pi/5) 0; cos(4*pi/5) sin(4*pi/5) 0; cos(6*pi/5) sin(6*pi/5) 0; cos(8*pi/5) sin(8*pi/5) 0; cos(10*pi/5) sin(10*pi/5) 0;]&#39;))
D = DeformationPath(F, [], 100; step_size=0.005)
animate(D,F,&quot;bodyhinge_pyramid_motion&quot;; filetype=&quot;mp4&quot;, animate_rotation=true, rotation_frames=450, padding=0.01)</code></pre><video controls="controls" width="100%" height="auto" style="max-width: 850px;">
  <source src="/DeformationPaths.jl/assets/bodyhinge_pyramid_motion.mp4" type="video/mp4">
  Your browser does not support the video tag.
</video><h3 id="Polytopes-with-Coplanarity-Constraints"><a class="docs-heading-anchor" href="#Polytopes-with-Coplanarity-Constraints">Polytopes with Coplanarity Constraints</a><a id="Polytopes-with-Coplanarity-Constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Polytopes-with-Coplanarity-Constraints" title="Permalink"></a></h3><p>Polytopes are geometric objects with flat sides. We model them as a collection of vertices, edges and facets. We fix their edge lengths and constrain facets to remain flat by requiring that all edges are normal to the unit outer facet normal. We can compute a deformation of the cuboctahedron using the following code:</p><pre><code class="language-julia hljs">F = Polytope([[1,5,9],[1,5,3,7],[1,7,11],[1,9,2,11],[2,9,6],[2,11,8],[3,5,10],[3,7,12],[3,10,4,12],[4,10,6],[4,12,8],[6,4,8,2],[5,9,6,10],[7,11,8,12]], Matrix([1 1 0; -1 1 0; 1 -1 0; -1 -1 0; 1 0 1; -1 0 1; 1 0 -1; -1 0 -1; 0 1 1; 0 -1 1; 0 1 -1; 0 -1 -1;]&#39;))
D = DeformationPath(F, [], 200; step_size=0.01, newton_tol=1e-2)
animate(D,F,&quot;cuboctahedron_motion&quot;; filetype=&quot;mp4&quot;)</code></pre><video controls="controls" width="100%" height="auto" style="max-width: 850px;">
  <source src="/DeformationPaths.jl/assets/cuboctahedron_motion.mp4" type="video/mp4">
  Your browser does not support the video tag.
</video><h3 id="Deformation-Paths-of-Polytopes-Induced-by-Edge-Contractions"><a class="docs-heading-anchor" href="#Deformation-Paths-of-Polytopes-Induced-by-Edge-Contractions">Deformation Paths of Polytopes Induced by Edge-Contractions</a><a id="Deformation-Paths-of-Polytopes-Induced-by-Edge-Contractions-1"></a><a class="docs-heading-anchor-permalink" href="#Deformation-Paths-of-Polytopes-Induced-by-Edge-Contractions" title="Permalink"></a></h3><p>Even when a polytope with edge-length and facet planarity constraints (see previous section) is rigid, we can induce deformation paths by contracting edges and facets. The ability to independently choose edges for this procedure seems to depend on the rigidity properties of the polytope. For example, for the flexible cube it is impossible to induce deformation paths simply by changing a single edge. For the regular dodecahedron, we can induce an edge-contraction sequence using the following code: </p><pre><code class="language-julia hljs">F = Polytope([[15,10,9,14,1],[2,6,12,11,5],[5,11,7,3,19],[11,12,8,16,7],[12,6,20,4,8],[6,2,13,18,20],[2,5,19,17,13],[4,20,18,10,15],[18,13,17,9,10],[17,19,3,14,9],[3,7,16,1,14],[16,8,4,15,1]], Matrix([-1.376381920471174 0 0.2628655560595668; 1.376381920471174 0 -0.2628655560595668; -0.4253254041760200 -1.309016994374947 0.2628655560595668; -0.4253254041760200 1.309016994374947 0.2628655560595668; 1.113516364411607 -0.8090169943749474 0.2628655560595668; 1.113516364411607 0.8090169943749474 0.2628655560595668; -0.2628655560595668 -0.8090169943749474 1.113516364411607; -0.2628655560595668 0.8090169943749474 1.113516364411607; -0.6881909602355868 -0.5000000000000000 -1.113516364411607; -0.6881909602355868 0.5000000000000000 -1.113516364411607; 0.6881909602355868 -0.5000000000000000 1.113516364411607; 0.6881909602355868 0.5000000000000000 1.113516364411607; 0.8506508083520399 0 -1.113516364411607; -1.113516364411607 -0.8090169943749474 -0.2628655560595668; -1.113516364411607 0.8090169943749474 -0.2628655560595668; -0.8506508083520399 0 1.113516364411607; 0.2628655560595668 -0.8090169943749474 -1.113516364411607; 0.2628655560595668 0.8090169943749474 -1.113516364411607; 0.4253254041760200 -1.309016994374947 -0.2628655560595668; 0.4253254041760200 1.309016994374947 -0.2628655560595668]&#39;))
D = DeformationPath_EdgeContraction(F, [9, 10], 0.5)
animate(D1,F,&quot;dodecahedron_EdgeContraction_motion&quot;; filetype=&quot;mp4&quot;)</code></pre><video controls="controls" width="100%" height="auto" style="max-width: 850px;">
  <source src="/DeformationPaths.jl/assets/dodecahedron_EdgeContraction_motion.mp4" type="video/mp4">
  Your browser does not support the video tag.
</video><h3 id="Volume-Hypergraphs"><a class="docs-heading-anchor" href="#Volume-Hypergraphs">Volume Hypergraphs</a><a id="Volume-Hypergraphs-1"></a><a class="docs-heading-anchor-permalink" href="#Volume-Hypergraphs" title="Permalink"></a></h3><p>Given a <span>$d+1$</span>-uniform hypergraph <span>$G=(V,E)$</span> and a realization <span>$p:V\rightarrow \mathbb{R}^d$</span>, we can constrain the volume of its simplicial faces via the determinant of the matrix that can be obtained by adding a row consisting of only ones to the realized vertices belonging to a facet. The <code>VolumeHypergraph</code> class allows us to create such structures, for instance a 2-dimensional realization of the octahedral graph with missing faces:</p><pre><code class="language-julia hljs">F = VolumeHypergraph([[1,3,6],[1,2,5],[2,3,4],[1,5,6],[6,4,5]], Matrix([0 0; 3 0; 0 3; 1 1; 1 0.5; 0.5 1]&#39;))
D = DeformationPath(F, [0.333, 1], 350; step_size=0.002)
animate(D, F,&quot;octahedral_decomposition_motion&quot;; fixed_triangle=(6,4,5), skip_stretch=false, target_stretch=0.5, tip_value=0.5)</code></pre><video controls="controls" width="100%" height="auto" style="max-width: 850px;">
  <source src="/DeformationPaths.jl/assets/octahedral_decomposition_motion.mp4" type="video/mp4">
  Your browser does not support the video tag.
</video><p>In this class, we have additional options. We can fix a triangle using <code>fixed_triangle=(6,4,5)</code>. The rescaling can be skipped using <code>skip_stretch=true</code>. The first two vertices are fixed to the origin and the <span>$x$</span>-axis, respectively. The third vertex is transformed to the point <code>(target_stretch, tip_value)</code>.</p><h3 id="Spherical-Disk-Packings"><a class="docs-heading-anchor" href="#Spherical-Disk-Packings">Spherical Disk Packings</a><a id="Spherical-Disk-Packings-1"></a><a class="docs-heading-anchor-permalink" href="#Spherical-Disk-Packings" title="Permalink"></a></h3><p>Besides planar disk packings, spherical disk packings have also garnered interest in recent times. Instead of the Euclidean distance, the inversive distance is used as a constraint here. The coordinates <span>$(a,b,c)$</span> of the packing&#39;s vertices are represented by affine hyperplanes of the form <span>$ax+by+cy=1$</span>. This choice makes it possible to compute the inversive distance in a particularly elegant way. We can generate a <code>SphericalDiskPacking</code> object using its contacts and a realization so that each point has a norm of at least 1. Again, we can pin vertices via the keyword <code>pinned_vertices</code>. For example, we can create a deformation of the spherical disk packing corresponding to the flexible Bricard octahedron using the following commands:</p><pre><code class="language-julia hljs">F = SphericalDiskPacking([(1,2),(1,3),(1,4),(1,5),(2,3),(2,4),(3,5),(4,5),(2,6),(3,6),(4,6),(5,6)], Matrix([sqrt(2) 0 0; 0 sqrt(2) 0; 0 0 sqrt(2); 0 -sqrt(2) 0; 0 0 -sqrt(2); -sqrt(2) 0 0]&#39;); pinned_vertices=[1])
D = DeformationPath(F, [1], 250; step_size=0.01)
animate(D,F,&quot;sphericaldiskpacking_motion&quot;)</code></pre><video controls="controls" width="100%" height="auto" style="max-width: 850px;">
  <source src="/DeformationPaths.jl/assets/sphericaldiskpacking_motion.mp4" type="video/mp4">
  Your browser does not support the video tag.
</video><h2 id="Exported-functions"><a class="docs-heading-anchor" href="#Exported-functions">Exported functions</a><a id="Exported-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Exported-functions" title="Permalink"></a></h2><h3 id="[Geometric-Constraint-Systems](ConstraintSystems.md)"><a class="docs-heading-anchor" href="#[Geometric-Constraint-Systems](ConstraintSystems.md)"><a href="../ConstraintSystems/">Geometric Constraint Systems</a></a><a id="[Geometric-Constraint-Systems](ConstraintSystems.md)-1"></a><a class="docs-heading-anchor-permalink" href="#[Geometric-Constraint-Systems](ConstraintSystems.md)" title="Permalink"></a></h3><ul><li><code>ConstraintSystem</code>: Creates a general <code>ConstraintSystem</code> object. </li><li><code>Framework</code>, <code>AngularFramework</code> and <code>FrameworkOnSurface</code>: Creates a bar-and-joint framework object, optinally with angular constraints or constrained to a surface.</li><li><code>SpherePacking</code>: Creates a sticky sphere packing object.</li><li><code>Polytope</code>: Creates a polytope with edge-length and coplanarity constraints.</li><li><code>BodyHinge</code>: Creates a body-hinge framework.</li><li><code>VolumeHypergraph</code>: Creates a volume-constrained hypergraph object.</li><li><code>SphericalDiskPacking</code>: Creates a <code>SphericalDiskPacking</code> object. </li></ul><h3 id="[Deformation-Paths](DeformationPath.md)"><a class="docs-heading-anchor" href="#[Deformation-Paths](DeformationPath.md)"><a href="../DeformationPath/">Deformation Paths</a></a><a id="[Deformation-Paths](DeformationPath.md)-1"></a><a class="docs-heading-anchor-permalink" href="#[Deformation-Paths](DeformationPath.md)" title="Permalink"></a></h3><ul><li><code>DeformationPath</code>: Creates a deformation path corresponding to a given geometric constraint system.</li><li><code>DeformationPath_EdgeContraction</code>: Creates a deformation path of a <code>Polytope</code> induced by an edge-contraction.</li></ul><h3 id="[Visualization](Visualization.md)"><a class="docs-heading-anchor" href="#[Visualization](Visualization.md)"><a href="../Visualization/">Visualization</a></a><a id="[Visualization](Visualization.md)-1"></a><a class="docs-heading-anchor-permalink" href="#[Visualization](Visualization.md)" title="Permalink"></a></h3><ul><li><code>animate</code>: Animates a deformation path. </li><li><code>plot</code>: Plots the given realization of a geometric constraint system.</li><li><code>project_deformation_random</code>: Visualizes a random projection of the computed deformation path to <span>$\mathbb{R}^2$</span> or <span>$\mathbb{R}^3$</span>. This can reveal insights into the geometry of the deformation space.</li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../DeformationPath/">DeformationPath »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Thursday 9 October 2025 13:51">Thursday 9 October 2025</span>. Using Julia version 1.10.10.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
