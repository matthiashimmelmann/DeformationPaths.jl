var documenterSearchIndex = {"docs":
[{"location":"DeformationPath/#DeformationPath-Constructors","page":"DeformationPath","title":"DeformationPath Constructors","text":"","category":"section"},{"location":"DeformationPath/#Main.DeformationPaths.DeformationPath","page":"DeformationPath","title":"Main.DeformationPaths.DeformationPath","text":"DeformationPath(G, motion_samples[; tol])\nDeformationPath(G, flex_mult, num_steps, type[; step_size, tol, random_flex, symmetric_newton, start_point])\nDeformationPath(F, flex_mult, num_steps[; random_flex, kwargs...])\n\nClass for constructing approximate deformation paths.\n\nAttributes\n\nG::ConstraintSystem: The geometric constraint system for which the deformation is computes.\nstep_size::Real: The step size of the deformation path. \nmotion_samples::Vector{<:Vector{<:Real}}: Points in the configuration space representing the approximate motion.\nmotion_matrices::Vector{<:Matrix{<:Real}}: The points in motion_samples as distributed into realizations given by dxn matrices for the dimension d and the number of vertices n.\nflex_mult::Vector{<:Real}: The initial infinitesimal flex as a linear combination of the nontrivial infinitesimal flexes at the realization provided by the underlying geometric constraint system.\n_contacts::Vector: In some cases (such as sphere packings), the contacts can change during the deformation. This is reflected by this attribute.\n\nArguments\n\nG::ConstraintSystem: The underlying geometric constraint system.\nmotion_samples::Vector{<:Vector{<:Real}}: List of previously computed realizations in array format.\nflex_mult::Vector: The initial infinitesimal flex as a linear combination of the nontrivial infinitesimal flexes at the realization provided by the underlying geometric constraint system.\nnum_steps::Int: Number of steps the algorithm is supposed to take. \ntype::DataType: Type of the geometric constraint system for computing the trivial infinitessimal flexes. Possible values: \"framework\", \"angularframework\", \"frameworkonsurface\", \"hypergraph\", \"polytope\", \"diskpacking\", \"bodyhinge\" and \"sphericaldiskpacking\".\nstep_size::Real: Step size of the deformation path. \ntol::Real (optional): Numerical tolerance for the approximation that is used for asserting the correctness of the approximation. Default value: 1e-8.\nrandom_flex::Bool (optional): If flex_mult is not provided (e.g. as []), we can instead provide a random linear combination (true) or it is uniformly chosen as [1,...,1] (false). Default value: false.\nsymmetric_newton::Bool (optional): It is possible to use the slightly more efficient symmetric Newton method (true) that uses fewer evaluations of the Jacobian, but may take more iterations. Alternatively, the standard Newton's method is used. Default value: false.\nstart_point::Union{Nothing, Vector{<:Real}} (optional): Either, we can explicitly and manually provide a start point for the deformation path or the realization in G is automatically selected. Default value: nothing.\n\nExamples\n\njulia> F = Framework([(1,2)], [0 0; 1 0;])\njulia> motion_samples = [[0,0,cos(θ),sin(θ)] for θ in 0:0.025:pi/2]\njulia> DeformationPath(F.G, motion_samples)\nDeformation Path:\n        Constraint System:\n                Vertices:       [1, 2]\n                Equations:      [-1.0 + (x₁₋₁ - x₁₋₂)^2 + (x₂₋₁ - x₂₋₂)^2]\n                Realization:    0.0     1.0\n                                0.0     0.0\n        Motion:         [\n                                [0.0, 0.0, 1.0, ...],\n                                [0.0, 0.0, 0.9996875162757026, ...],\n                                [0.0, 0.0, 0.9987502603949663, ...],\n                                [0.0, 0.0, 0.9971888181122075, ...],\n                        ...]\n\n\njulia> F = Framework([(1,2),(2,3),(3,4),(4,1)], Matrix([0 0; 1 0; 1 1; 0 1;]'))\njulia> DeformationPath(F.G, [], 4, typeof(F); step_size=0.1)\nDeformation Path:\n        Constraint System:\n                Vertices:       [1, 2, 3, 4]\n                Equations:      [-1.0 + (x₁₋₁ - x₁₋₂)^2 + (x₂₋₁ - x₂₋₂)^2, -1.0 + (x₁₋₂ - x₁₋₃)^2 + (x₂₋₂ - x₂₋₃)^2, ...]\n                Realization:    0.0     0.0\n                                1.0     0.0\n                                1.0     1.0\n                                0.0     1.0\n        Motion:         [\n                                [0.0, 0.0, 1.0, ...],\n                                [0.03651261273911354, 0.03651261273911352, 1.0340219488467464, ...],\n                                [0.07533400807826349, 0.07533400807826351, 1.0653837593220445, ...],\n                                [0.11627080392220492, 0.11627080392220503, 1.0939292079679943, ...],\n                        ...]\n        Step Size:      0.1\n        Flex Selector:  [1.0]\n\n\njulia> F = BodyHinge([[1,2,3],[1,3,4],[1,4,5],[1,5,2]], Matrix([0 0 1; 1 -1 0; 1 1 0; -1 1 0; -1 -1 0;]'))\njulia> DeformationPath(F, [], 5; step_size=0.01)\nDeformation Path:\n        Constraint System:\n                Vertices:       [1, 2, 3, 4, 5]\n                Equations:      [-4.0 + (x₁₋₄ - x₁₋₅)^2 + (x₂₋₄ - x₂₋₅)^2 + (x₃₋₄ - x₃₋₅)^2, -3.0 + (x₁₋₁ - x₁₋₂)^2 + (x₂₋₁ - x₂₋₂)^2 + (x₃₋₁ - x₃₋₂)^2, ...]\n                Realization:    0.0     0.0     1.0\n                                1.0     -1.0    0.0\n                                1.0     1.0     0.0\n                                -1.0    1.0     0.0\n        Motion:         [\n                                [0.0, 0.0, 1.0, ...],\n                                [4.508862520636648e-17, 9.98697453244557e-18, 1.0001664436067044, ...],\n                                [-1.4097240946269324e-17, 4.145853894815855e-17, 1.0006643327504479, ...],\n                                [-5.097629777228046e-17, 3.7479573223418395e-17, 1.0014893737348445, ...],\n                        ...]\n        Step Size:      0.05\n        Flex Selector:  [1.0]\n\n\n\n\n\n\n","category":"type"},{"location":"DeformationPath/#Main.DeformationPaths.DeformationPath_EdgeContraction-Tuple{Main.DeformationPaths.Polytope, Union{Tuple{Int64, Int64}, Vector{Int64}}, Real}","page":"DeformationPath","title":"Main.DeformationPaths.DeformationPath_EdgeContraction","text":"DeformationPath_EdgeContraction(F::Polytope, flex_mult, num_steps[; kwargs...])\n\nCreate an approximate continuous motion from a Polytope object induced by contracting a single edge given by edge_for_contraction.\n\nArguments\n\nF::Polytope: The underlying polytope.\nedge_for_contraction::Union{Tuple{Int,Int},Vector{Int}}: The edge in F that is supposed to be contracted.\ncontraction_target::Real: To what length ratio the edge is suppsed to be contracted.\nstep_size::Real: Step size of the deformation path. \ntol::Real (optional): Numerical tolerance for the approximation that is used for asserting the correctness of the approximation. Default value: 1e-8.\n\n\n\n\n\n","category":"method"},{"location":"usage/#Guide-for-Using-the-package-DeformationPaths.jl","page":"Usage Guide","title":"Guide for Using the package DeformationPaths.jl","text":"","category":"section"},{"location":"usage/","page":"Usage Guide","title":"Usage Guide","text":"This package allows the approximation of deformation paths corresponding to a variety of geometric constraint systems. To accomplish this, we iteratively apply a combination of Euler predictor steps and Gauss-Newton corrector steps to take a local stpe on the constraint set. This approach is known as homotopy continuation. ","category":"page"},{"location":"usage/#Installation","page":"Usage Guide","title":"Installation","text":"","category":"section"},{"location":"usage/","page":"Usage Guide","title":"Usage Guide","text":"julia> ]\n(@v1.10) pkg> add DeformationPaths","category":"page"},{"location":"usage/#Usage","page":"Usage Guide","title":"Usage","text":"","category":"section"},{"location":"usage/","page":"Usage Guide","title":"Usage Guide","text":"using DeformationPaths","category":"page"},{"location":"usage/#Bar-and-Joint-Frameworks","page":"Usage Guide","title":"Bar-and-Joint Frameworks","text":"","category":"section"},{"location":"usage/","page":"Usage Guide","title":"Usage Guide","text":"Bar-and-Joint frameworks are given by embedded graphs whose edges are equipped with Euclidean distance constraints. We can create a deformation path using the constructor DeformationPath. For example, a deformation path starting in a realization of the complete bipartite graph K_24 (giving rise to a Framework) can be computed using the following code. For instance, we can generate the framework on a list of edges and a realization given by a matrix. Here, vertex i corresponds to the i-th column in the matrix.","category":"page"},{"location":"usage/","page":"Usage Guide","title":"Usage Guide","text":"F = Framework([[1,3],[1,4],[1,5],[1,6],[2,3],[2,4],[2,5],[2,6]], Matrix([0 0; 0 1; 1 -1; 1 0; 1 1; 1 2]'))\nD = DeformationPath(F, [1], 500; step_size=0.025)\nanimate(D,F,\"completebipartite_motion\")","category":"page"},{"location":"usage/","page":"Usage Guide","title":"Usage Guide","text":"<video controls=\"controls\" width=\"100%\" height=\"auto\" style=\"max-width: 800px;\">\n  <source src=\"/DeformationPaths.jl/assets/completebipartite_motion.mp4\" type=\"video/mp4\">\n  Your browser does not support the video tag.\n</video>","category":"page"},{"location":"usage/","page":"Usage Guide","title":"Usage Guide","text":"There is only a single infinitesimal motion, which we select via setting flex_mult=[1]. This input selects the initial tangent vector sum_i=1^r c_i mathbfq_i for a basis (mathbfq_1dotsmathbfq_r) of nontrivial infinitesimal flexes. We compute 500 predictor corrector steps with a step size of 0.025 and save the resulting animation under the file name \"completebipartite_motion.png\" using the method animate.","category":"page"},{"location":"usage/","page":"Usage Guide","title":"Usage Guide","text":"We can also pin vertices in the framework, which are depicted as triangles. This is exemplified through the following animation of the cuspidal double Watt mechanism:","category":"page"},{"location":"usage/","page":"Usage Guide","title":"Usage Guide","text":"F = Framework([[1,2],[2,3],[2,4],[3,9],[3,4],[3,5],[4,5],[5,6],[6,7],[7,8],[7,9],[8,9],[8,10],[9,10],[10,11]], Matrix([0 0; 1 0; 2 1; 1 2; 3 2; 4 2; 5 2; 7 2; 6 1; 7 0; 8 0;]'); pinned_vertices=[1,6,11])\nD = DeformationPath(F, [], 500; step_size=0.05)\nanimate(D,F,\"double_watt_motion\"; padding=0.35, fixed_pair=(1,6), fixed_direction=[4,2])","category":"page"},{"location":"usage/","page":"Usage Guide","title":"Usage Guide","text":"<video controls=\"controls\" width=\"100%\" height=\"auto\" style=\"max-width: 800px;\">\n  <source src=\"/DeformationPaths.jl/assets/double_watt_motion.mp4\" type=\"video/mp4\">\n  Your browser does not support the video tag.\n</video>","category":"page"},{"location":"usage/","page":"Usage Guide","title":"Usage Guide","text":"By setting flex_mult to be an empty array [], we tell the program to automatically select the flex given by the sum of the basis vectors of the nontrivial infinitesimal flex space at the starting configuration. ","category":"page"},{"location":"usage/","page":"Usage Guide","title":"Usage Guide","text":"Remarkably, this mechanism has a cusp singularity that the deformation path approximation algorithm manages to accurately traverse via an acceleration-based direction-detection method. Moreover, this is a stressed framework, for which typically Newton's method does not converge well; our choice of implementation for Newton's method does not have this problem.","category":"page"},{"location":"usage/#Frameworks-on-Surfaces","page":"Usage Guide","title":"Frameworks on Surfaces","text":"","category":"section"},{"location":"usage/","page":"Usage Guide","title":"Usage Guide","text":"Constraining a bar-and-joint frameworks' vertices to a surface provides an important and well-studied restriction. In the FrameworkOnSurface constructor, the underlying surface is provided as an implicit function in the method's third argument. The following example provides a motion of a framework on a 4-cycle graph that is constrained to the one hyperboloid.","category":"page"},{"location":"usage/","page":"Usage Guide","title":"Usage Guide","text":"F = FrameworkOnSurface([[1,2],[2,3],[3,4],[1,4]], Matrix([-sqrt(1/2) -sqrt(1/2) -1; -1 0 0; 0 1 0; sqrt(1/2) sqrt(1/2) 1]'), x->x[1]^2+x[2]^2-x[3]^2-1)\nD = DeformationPath(F, [1,1], 350; step_size=0.035)\nanimate(D,F,\"squareonhyperboloid_motion\"; animate_rotation=true, filetype=\"mp4\")","category":"page"},{"location":"usage/","page":"Usage Guide","title":"Usage Guide","text":"<video controls=\"controls\" width=\"100%\" height=\"auto\" style=\"max-width: 800px;\">\n  <source src=\"/DeformationPaths.jl/assets/squareonhyperboloid_motion.mp4\" type=\"video/mp4\">\n  Your browser does not support the video tag.\n</video>","category":"page"},{"location":"usage/#Angle-Constrained-Frameworks","page":"Usage Guide","title":"Angle-Constrained Frameworks","text":"","category":"section"},{"location":"usage/","page":"Usage Guide","title":"Usage Guide","text":"Beyond bar-joint frameworks, angle-constrained frameworks are popular objects of study in rigidity theory. These objects come with sequences of three vertices, whose interior angle is constrained to be constant, and can be created using the command AngularFramework. We provide a visual representation of Thales' Theorem as an example:","category":"page"},{"location":"usage/","page":"Usage Guide","title":"Usage Guide","text":"F = AngularFramework([[1,3,2]], Matrix([-1 0; 1 0; -sqrt(1/2) sqrt(1/2);]'); pinned_vertices=[1,2])\nD = DeformationPath(F, [1], 250; step_size=0.025)\nanimate(D,F,\"thales_motion\"; padding=0.075, pin_point_offset=0.075, filetype=\"mp4\")","category":"page"},{"location":"usage/","page":"Usage Guide","title":"Usage Guide","text":"<video controls=\"controls\" width=\"100%\" height=\"auto\" style=\"max-width: 800px;\">\n  <source src=\"/DeformationPaths.jl/assets/thales_motion.mp4\" type=\"video/mp4\">\n  Your browser does not support the video tag.\n</video>","category":"page"},{"location":"usage/#Sticky-Sphere-Packings","page":"Usage Guide","title":"Sticky Sphere Packings","text":"","category":"section"},{"location":"usage/","page":"Usage Guide","title":"Usage Guide","text":"Sphere packings are given by a non-overlapping arrangements of spheres with fixed radii in mathbbR^2. They are called sticky, when existing contacts cannot be broken. In this package, spheres that form a contact during the deformation path computation remain in contact. The SpherePacking class takes a list of radii and a realization as input. As the optional parameter pinned_vertices, we can specify which vertices in the disk packings should be pinned. As an example, we can create an animation using the following code:","category":"page"},{"location":"usage/","page":"Usage Guide","title":"Usage Guide","text":"F = SpherePacking([1.,1.,1.,1.], Matrix([0 0; 1.75 -sqrt(2^2-(1.75)^2); 3.5 0; 4.5 sqrt(3)]'); pinned_vertices=[1])\nD = DeformationPath(F, [1,1], 250; step_size=0.025)\nanimate(D,F,\"diskpacking_motion\")","category":"page"},{"location":"usage/","page":"Usage Guide","title":"Usage Guide","text":"<video controls=\"controls\" width=\"100%\" height=\"auto\" style=\"max-width: 800px;\">\n  <source src=\"/DeformationPaths.jl/assets/diskpacking_motion.mp4\" type=\"video/mp4\">\n  Your browser does not support the video tag.\n</video>","category":"page"},{"location":"usage/","page":"Usage Guide","title":"Usage Guide","text":"This construction also works in 3D, as demonstrated by the following code:","category":"page"},{"location":"usage/","page":"Usage Guide","title":"Usage Guide","text":"F = SpherePacking([1.,1.,1.,1.], Matrix([0 0 0; 2 0 0; 0 2 0; 0 0 2]'), pinned_vertices = [1,2])\nD = DeformationPath(F, [1,1,1], 500; step_size=0.04)\nanimate(D,F,\"spherepacking_motion\"; filetype=\"mp4\")","category":"page"},{"location":"usage/","page":"Usage Guide","title":"Usage Guide","text":"<video controls=\"controls\" width=\"100%\" height=\"auto\" style=\"max-width: 800px;\">\n  <source src=\"/DeformationPaths.jl/assets/spherepacking_motion.mp4\" type=\"video/mp4\">\n  Your browser does not support the video tag.\n</video>","category":"page"},{"location":"usage/#Body-Hinge-Frameworks","page":"Usage Guide","title":"Body-Hinge Frameworks","text":"","category":"section"},{"location":"usage/","page":"Usage Guide","title":"Usage Guide","text":"Body-hinge frameworks are composed of rigid bodies – think of polygonal faces that are not allowed to shift shapes – that are joined along edges. Therefore, bodies are allowed to rotate around edges, comparable to a hinge. Such an object can be created using the BodyHinge constructor. The following example creates a flexible pyramid with a pentagonal face:","category":"page"},{"location":"usage/","page":"Usage Guide","title":"Usage Guide","text":"F = BodyHinge([[1,2,3],[1,3,4],[1,4,5],[1,5,6],[1,6,2]], Matrix([0 0 1; cos(2*pi/5) sin(2*pi/5) 0; cos(4*pi/5) sin(4*pi/5) 0; cos(6*pi/5) sin(6*pi/5) 0; cos(8*pi/5) sin(8*pi/5) 0; cos(10*pi/5) sin(10*pi/5) 0;]'))\nD = DeformationPath(F, [], 100; step_size=0.005)\nanimate(D,F,\"bodyhinge_pyramid_motion\"; filetype=\"mp4\", animate_rotation=true, rotation_frames=450, padding=0.01)","category":"page"},{"location":"usage/","page":"Usage Guide","title":"Usage Guide","text":"<video controls=\"controls\" width=\"100%\" height=\"auto\" style=\"max-width: 800px;\">\n  <source src=\"/DeformationPaths.jl/assets/bodyhinge_pyramid_motion.mp4\" type=\"video/mp4\">\n  Your browser does not support the video tag.\n</video>","category":"page"},{"location":"usage/#Polytopes-with-Coplanarity-Constraints","page":"Usage Guide","title":"Polytopes with Coplanarity Constraints","text":"","category":"section"},{"location":"usage/","page":"Usage Guide","title":"Usage Guide","text":"Polytopes are geometric objects with flat sides. We model them as a collection of vertices, edges and facets. We fix their edge lengths and constrain facets to remain flat by requiring that all edges are normal to the unit outer facet normal. We can compute a deformation of the cuboctahedron using the following code:","category":"page"},{"location":"usage/","page":"Usage Guide","title":"Usage Guide","text":"F = Polytope([[1,5,9],[1,5,3,7],[1,7,11],[1,9,2,11],[2,9,6],[2,11,8],[3,5,10],[3,7,12],[3,10,4,12],[4,10,6],[4,12,8],[6,4,8,2],[5,9,6,10],[7,11,8,12]], Matrix([1 1 0; -1 1 0; 1 -1 0; -1 -1 0; 1 0 1; -1 0 1; 1 0 -1; -1 0 -1; 0 1 1; 0 -1 1; 0 1 -1; 0 -1 -1;]'))\nD = DeformationPath(F, [], 200; step_size=0.01, newton_tol=1e-2)\nanimate(D,F,\"cuboctahedron_motion\"; filetype=\"mp4\")","category":"page"},{"location":"usage/","page":"Usage Guide","title":"Usage Guide","text":"<video controls=\"controls\" width=\"100%\" height=\"auto\" style=\"max-width: 800px;\">\n  <source src=\"/DeformationPaths.jl/assets/cuboctahedron_motion.mp4\" type=\"video/mp4\">\n  Your browser does not support the video tag.\n</video>","category":"page"},{"location":"usage/#Deformation-Paths-of-Polytopes-Induced-by-Edge-Contractions","page":"Usage Guide","title":"Deformation Paths of Polytopes Induced by Edge-Contractions","text":"","category":"section"},{"location":"usage/","page":"Usage Guide","title":"Usage Guide","text":"Even when a polytope with edge-length and facet planarity constraints (see previous section) is rigid, we can induce deformation paths by contracting edges and facets. The ability to independently choose edges for this procedure seems to depend on the rigidity properties of the polytope. For example, for the flexible cube it is impossible to induce deformation paths simply by changing a single edge. For the regular dodecahedron, we can induce an edge-contraction sequence using the following code: ","category":"page"},{"location":"usage/","page":"Usage Guide","title":"Usage Guide","text":"F = Polytope([[15,10,9,14,1],[2,6,12,11,5],[5,11,7,3,19],[11,12,8,16,7],[12,6,20,4,8],[6,2,13,18,20],[2,5,19,17,13],[4,20,18,10,15],[18,13,17,9,10],[17,19,3,14,9],[3,7,16,1,14],[16,8,4,15,1]], Matrix([-1.376381920471174 0 0.2628655560595668; 1.376381920471174 0 -0.2628655560595668; -0.4253254041760200 -1.309016994374947 0.2628655560595668; -0.4253254041760200 1.309016994374947 0.2628655560595668; 1.113516364411607 -0.8090169943749474 0.2628655560595668; 1.113516364411607 0.8090169943749474 0.2628655560595668; -0.2628655560595668 -0.8090169943749474 1.113516364411607; -0.2628655560595668 0.8090169943749474 1.113516364411607; -0.6881909602355868 -0.5000000000000000 -1.113516364411607; -0.6881909602355868 0.5000000000000000 -1.113516364411607; 0.6881909602355868 -0.5000000000000000 1.113516364411607; 0.6881909602355868 0.5000000000000000 1.113516364411607; 0.8506508083520399 0 -1.113516364411607; -1.113516364411607 -0.8090169943749474 -0.2628655560595668; -1.113516364411607 0.8090169943749474 -0.2628655560595668; -0.8506508083520399 0 1.113516364411607; 0.2628655560595668 -0.8090169943749474 -1.113516364411607; 0.2628655560595668 0.8090169943749474 -1.113516364411607; 0.4253254041760200 -1.309016994374947 -0.2628655560595668; 0.4253254041760200 1.309016994374947 -0.2628655560595668]'))\nD = DeformationPath_EdgeContraction(F, [9, 10], 0.5)\nanimate(D1,F,\"dodecahedron_EdgeContraction_motion\"; filetype=\"mp4\")","category":"page"},{"location":"usage/","page":"Usage Guide","title":"Usage Guide","text":"<video controls=\"controls\" width=\"100%\" height=\"auto\" style=\"max-width: 800px;\">\n  <source src=\"/DeformationPaths.jl/assets/dodecahedron_EdgeContraction_motion.mp4\" type=\"video/mp4\">\n  Your browser does not support the video tag.\n</video>","category":"page"},{"location":"usage/#Volume-Hypergraphs","page":"Usage Guide","title":"Volume Hypergraphs","text":"","category":"section"},{"location":"usage/","page":"Usage Guide","title":"Usage Guide","text":"Given a d+1-uniform hypergraph G=(VE) and a realization pVrightarrow mathbbR^d, we can constrain the volume of its simplicial faces via the determinant of the matrix that can be obtained by adding a row consisting of only ones to the realized vertices belonging to a facet. The VolumeHypergraph class allows us to create such structures, for instance a 2-dimensional realization of the octahedral graph with missing faces:","category":"page"},{"location":"usage/","page":"Usage Guide","title":"Usage Guide","text":"F = VolumeHypergraph([[1,3,6],[1,2,5],[2,3,4],[1,5,6],[6,4,5]], Matrix([0 0; 3 0; 0 3; 1 1; 1 0.5; 0.5 1]'))\nD = DeformationPath(F, [0.333, 1], 350; step_size=0.002)\nanimate(D, F,\"octahedral_decomposition_motion\"; fixed_triangle=(6,4,5), skip_stretch=false, target_stretch=0.5, tip_value=0.5)","category":"page"},{"location":"usage/","page":"Usage Guide","title":"Usage Guide","text":"<video controls=\"controls\" width=\"100%\" height=\"auto\" style=\"max-width: 800px;\">\n  <source src=\"/DeformationPaths.jl/assets/octahedral_decomposition_motion.mp4\" type=\"video/mp4\">\n  Your browser does not support the video tag.\n</video>","category":"page"},{"location":"usage/","page":"Usage Guide","title":"Usage Guide","text":"In this class, we have additional options. We can fix a triangle using fixed_triangle=(6,4,5). The rescaling can be skipped using skip_stretch=true. The first two vertices are fixed to the origin and the x-axis, respectively. The third vertex is transformed to the point (target_stretch, tip_value).","category":"page"},{"location":"usage/#Spherical-Disk-Packings","page":"Usage Guide","title":"Spherical Disk Packings","text":"","category":"section"},{"location":"usage/","page":"Usage Guide","title":"Usage Guide","text":"Besides planar disk packings, spherical disk packings have also garnered interest in recent times. Instead of the Euclidean distance, the inversive distance is used as a constraint here. The coordinates (abc) of the packing's vertices are represented by affine hyperplanes of the form ax+by+cy=1. This choice makes it possible to compute the inversive distance in a particularly elegant way. We can generate a SphericalDiskPacking object using its contacts and a realization so that each point has a norm of at least 1. Again, we can pin vertices via the keyword pinned_vertices. For example, we can create a deformation of the spherical disk packing corresponding to the flexible Bricard octahedron using the following commands:","category":"page"},{"location":"usage/","page":"Usage Guide","title":"Usage Guide","text":"F = SphericalDiskPacking([(1,2),(1,3),(1,4),(1,5),(2,3),(2,4),(3,5),(4,5),(2,6),(3,6),(4,6),(5,6)], Matrix([sqrt(2) 0 0; 0 sqrt(2) 0; 0 0 sqrt(2); 0 -sqrt(2) 0; 0 0 -sqrt(2); -sqrt(2) 0 0]'); pinned_vertices=[1])\nD = DeformationPath(F, [1], 250; step_size=0.01)\nanimate(D,F,\"sphericaldiskpacking_motion\")","category":"page"},{"location":"usage/","page":"Usage Guide","title":"Usage Guide","text":"<video controls=\"controls\" width=\"100%\" height=\"auto\" style=\"max-width: 800px;\">\n  <source src=\"/DeformationPaths.jl/assets/sphericaldiskpacking_motion.mp4\" type=\"video/mp4\">\n  Your browser does not support the video tag.\n</video>","category":"page"},{"location":"usage/#Exported-functions","page":"Usage Guide","title":"Exported functions","text":"","category":"section"},{"location":"usage/#[Geometric-Constraint-Systems](ConstraintSystems.md)","page":"Usage Guide","title":"Geometric Constraint Systems","text":"","category":"section"},{"location":"usage/","page":"Usage Guide","title":"Usage Guide","text":"ConstraintSystem: Creates a general ConstraintSystem object. \nFramework, AngularFramework and FrameworkOnSurface: Creates a bar-and-joint framework object, optinally with angular constraints or constrained to a surface.\nSpherePacking: Creates a sticky sphere packing object.\nPolytope: Creates a polytope with edge-length and coplanarity constraints.\nBodyHinge: Creates a body-hinge framework.\nVolumeHypergraph: Creates a volume-constrained hypergraph object.\nSphericalDiskPacking: Creates a SphericalDiskPacking object. ","category":"page"},{"location":"usage/#[Deformation-Paths](DeformationPath.md)","page":"Usage Guide","title":"Deformation Paths","text":"","category":"section"},{"location":"usage/","page":"Usage Guide","title":"Usage Guide","text":"DeformationPath: Creates a deformation path corresponding to a given geometric constraint system.\nDeformationPath_EdgeContraction: Creates a deformation path of a Polytope induced by an edge-contraction.","category":"page"},{"location":"usage/#[Visualization](Visualization.md)","page":"Usage Guide","title":"Visualization","text":"","category":"section"},{"location":"usage/","page":"Usage Guide","title":"Usage Guide","text":"animate: Animates a deformation path. \nplot: Plots the given realization of a geometric constraint system.\nproject_deformation_random: Visualizes a random projection of the computed deformation path to mathbbR^2 or mathbbR^3. This can reveal insights into the geometry of the deformation space.","category":"page"},{"location":"Visualization/#Visualization-Capabilities","page":"Visualization","title":"Visualization Capabilities","text":"","category":"section"},{"location":"Visualization/","page":"Visualization","title":"Visualization","text":"There are various visualization options that are shipped with the package. For instance, we can plot a geometric constraint system by calling","category":"page"},{"location":"Visualization/#Main.DeformationPaths.plot-Tuple{Union{Main.DeformationPaths.AngularFramework, Main.DeformationPaths.BodyHinge, Main.DeformationPaths.Framework, Main.DeformationPaths.FrameworkOnSurface, Main.DeformationPaths.Polytope, Main.DeformationPaths.SpherePacking, Main.DeformationPaths.SphericalDiskPacking, Main.DeformationPaths.VolumeHypergraph}, String}","page":"Visualization","title":"Main.DeformationPaths.plot","text":"plot(F, filename)\n\nPlot the geometric constraint system F.\n\nThis is a wrapper method for plotting of the individual geometric constraint systems.  It calls one of the following: plot_flexes!, plot_framework, plot_frameworkonsurface, plot_hypergraph, plot_polytope, plot_spherepacking and plot_sphericaldiskpacking.\n\n\n\n\n\n","category":"method"},{"location":"Visualization/","page":"Visualization","title":"Visualization","text":"A specific continuous motion of a geometric constraint system can be animated via","category":"page"},{"location":"Visualization/#Main.DeformationPaths.animate-Tuple{Main.DeformationPaths.DeformationPath, Any, String}","page":"Visualization","title":"Main.DeformationPaths.animate","text":"animate(D, F, filename)\n\nCreate an animation of a geometric constraint system F given a previously computed deformation path.\n\nThis is a wrapper method for animations for the individual geometric constraint systems.  It calls one of the following: animate2D_framework, animate3D_framework, animate3D_frameworkonsurface, animate2D_hypergraph, animate3D_polytope, animate2D_diskpacking, animate3D_spherepacking and animate3D_sphericaldiskpacking.\n\n\n\n\n\n","category":"method"},{"location":"Visualization/","page":"Visualization","title":"Visualization","text":"And we can also visualize a random projection to 2D or 3D of deformation paths:","category":"page"},{"location":"Visualization/#Main.DeformationPaths.project_deformation_random-Tuple{Union{Main.DeformationPaths.DeformationPath, Vector{Main.DeformationPaths.DeformationPath}}, Int64}","page":"Visualization","title":"Main.DeformationPaths.project_deformation_random","text":"project_deformation_random(D, F, filename)\n\nCompute a random projection of deformation paths.\n\nThis method can either take a single deformation path or a vector of deformation paths and projects it to curves in 2D or 3D. This makes it possible to visualize high-dimensional deformation spaces. \n\n\n\n\n\n","category":"method"},{"location":"Visualization/#Plotting-Capabilities","page":"Visualization","title":"Plotting Capabilities","text":"","category":"section"},{"location":"Visualization/#Main.DeformationPaths.plot_flexes!-Tuple{Any, Union{Main.DeformationPaths.AngularFramework, Main.DeformationPaths.BodyHinge, Main.DeformationPaths.Framework, Main.DeformationPaths.FrameworkOnSurface, Main.DeformationPaths.Polytope, Main.DeformationPaths.SpherePacking, Main.DeformationPaths.SphericalDiskPacking, Main.DeformationPaths.VolumeHypergraph}, Int64, Vararg{Any, 4}}","page":"Visualization","title":"Main.DeformationPaths.plot_flexes!","text":"plot_flexes!(ax, F, flex_Real, flex_color, flex_scale, linewidth, arrowsize)\n\nAdd infinitesimal flexes to a plot of a geometric constraint system\n\n\n\n\n\n","category":"method"},{"location":"Visualization/#Main.DeformationPaths.plot_framework-Tuple{Union{Main.DeformationPaths.AngularFramework, Main.DeformationPaths.Framework}, String}","page":"Visualization","title":"Main.DeformationPaths.plot_framework","text":"plot_framework(F, filename)\n\nPlot a bar-joint or angular framework.\n\n\n\n\n\n","category":"method"},{"location":"Visualization/#Main.DeformationPaths.plot_frameworkonsurface-Tuple{Main.DeformationPaths.FrameworkOnSurface, String}","page":"Visualization","title":"Main.DeformationPaths.plot_frameworkonsurface","text":"plot_frameworkonsurface(F, filename)\n\nPlot a bar-joint framework constrained to a surface.\n\n\n\n\n\n","category":"method"},{"location":"Visualization/#Main.DeformationPaths.plot_spherepacking-Tuple{Main.DeformationPaths.SpherePacking, String}","page":"Visualization","title":"Main.DeformationPaths.plot_spherepacking","text":"plot_spherepacking(F, filename)\n\nPlot a sphere packing.\n\n\n\n\n\n","category":"method"},{"location":"Visualization/#Main.DeformationPaths.plot_sphericaldiskpacking-Tuple{Main.DeformationPaths.SphericalDiskPacking, String}","page":"Visualization","title":"Main.DeformationPaths.plot_sphericaldiskpacking","text":"plot_sphericaldiskpacking(F, filename)\n\nPlot a spherical disk packing.\n\n\n\n\n\n","category":"method"},{"location":"Visualization/#Main.DeformationPaths.plot_hypergraph-Tuple{Main.DeformationPaths.VolumeHypergraph, String}","page":"Visualization","title":"Main.DeformationPaths.plot_hypergraph","text":"plot_hypergraph(F, filename)\n\nPlot a volume-constrained hypergraph.\n\n\n\n\n\n","category":"method"},{"location":"Visualization/#Main.DeformationPaths.plot_polytope-Tuple{Union{Main.DeformationPaths.BodyHinge, Main.DeformationPaths.Polytope}, String}","page":"Visualization","title":"Main.DeformationPaths.plot_polytope","text":"plot_polytope(F, filename)\n\nPlot a polytope.\n\n\n\n\n\n","category":"method"},{"location":"Visualization/#Animation-Methods","page":"Visualization","title":"Animation Methods","text":"","category":"section"},{"location":"Visualization/#Main.DeformationPaths.animate-Tuple{Union{Main.DeformationPaths.AngularFramework, Main.DeformationPaths.BodyHinge, Main.DeformationPaths.Framework, Main.DeformationPaths.FrameworkOnSurface, Main.DeformationPaths.Polytope, Main.DeformationPaths.SpherePacking, Main.DeformationPaths.SphericalDiskPacking, Main.DeformationPaths.VolumeHypergraph}, String}","page":"Visualization","title":"Main.DeformationPaths.animate","text":"animate(F, filename[; flex_mult, random_flex, num_steps, step_size])\n\nCreate an animation of a geometric constraint system F.\n\n\n\n\n\n","category":"method"},{"location":"Visualization/#Main.DeformationPaths.animate2D_framework-Tuple{Main.DeformationPaths.DeformationPath, Union{Main.DeformationPaths.AngularFramework, Main.DeformationPaths.Framework}, String}","page":"Visualization","title":"Main.DeformationPaths.animate2D_framework","text":"animate2D_framework(D, F, filename)\n\nCompute an animation for a 2-dimensional bar-joint framework.\n\n\n\n\n\n","category":"method"},{"location":"Visualization/#Main.DeformationPaths.animate3D_framework-Tuple{Main.DeformationPaths.DeformationPath, Union{Main.DeformationPaths.AngularFramework, Main.DeformationPaths.Framework}, String}","page":"Visualization","title":"Main.DeformationPaths.animate3D_framework","text":"animate3D_framework(D, F, filename)\n\nCompute an animation for a 3-dimensional bar-joint framework.\n\n\n\n\n\n","category":"method"},{"location":"Visualization/#Main.DeformationPaths.animate3D_frameworkonsurface-Tuple{Main.DeformationPaths.DeformationPath, Main.DeformationPaths.FrameworkOnSurface, String}","page":"Visualization","title":"Main.DeformationPaths.animate3D_frameworkonsurface","text":"animate3D_frameworkonsurface(D, F, filename)\n\nCompute an animation for a 3-dimensional bar-joint framework constrained to a surface.\n\n\n\n\n\n","category":"method"},{"location":"Visualization/#Main.DeformationPaths.animate2D_hypergraph-Tuple{Main.DeformationPaths.DeformationPath, Main.DeformationPaths.VolumeHypergraph, String}","page":"Visualization","title":"Main.DeformationPaths.animate2D_hypergraph","text":"animate2D_hypergraph(D, F, filename)\n\nCompute an animation for a 2-dimensional volume hypergraph.\n\n\n\n\n\n","category":"method"},{"location":"Visualization/#Main.DeformationPaths.animate3D_polytope-Tuple{Main.DeformationPaths.DeformationPath, Union{Main.DeformationPaths.BodyHinge, Main.DeformationPaths.Polytope}, String}","page":"Visualization","title":"Main.DeformationPaths.animate3D_polytope","text":"animate3D_polytope(D, F, filename)\n\nCompute an animation for a 3-dimensional polytope.\n\n\n\n\n\n","category":"method"},{"location":"Visualization/#Main.DeformationPaths.animate2D_diskpacking-Tuple{Main.DeformationPaths.DeformationPath, Main.DeformationPaths.SpherePacking, String}","page":"Visualization","title":"Main.DeformationPaths.animate2D_diskpacking","text":"animate2D_diskpacking(D, F, filename)\n\nCompute an animation for a 2-dimensional sticky disk packing.\n\n\n\n\n\n","category":"method"},{"location":"Visualization/#Main.DeformationPaths.animate3D_spherepacking-Tuple{Main.DeformationPaths.DeformationPath, Main.DeformationPaths.SpherePacking, String}","page":"Visualization","title":"Main.DeformationPaths.animate3D_spherepacking","text":"animate3D_spherepacking(D, F, filename)\n\nCompute an animation for a 3-dimensional sticky sphere packing.\n\n\n\n\n\n","category":"method"},{"location":"Visualization/#Main.DeformationPaths.animate3D_sphericaldiskpacking-Tuple{Main.DeformationPaths.DeformationPath, Main.DeformationPaths.SphericalDiskPacking, String}","page":"Visualization","title":"Main.DeformationPaths.animate3D_sphericaldiskpacking","text":"animate3D_sphericaldiskpacking(D, F, filename)\n\nCompute an animation for a disk packing on the 2-sphere in the Minkowski metric.\n\n\n\n\n\n","category":"method"},{"location":"Auxiliary/#Auxiliary-Functions","page":"Auxiliary Methods","title":"Auxiliary Functions","text":"","category":"section"},{"location":"Auxiliary/#Rigidity-Checks","page":"Auxiliary Methods","title":"Rigidity Checks","text":"","category":"section"},{"location":"Auxiliary/#Main.DeformationPaths.is_rigid-Tuple{Union{Main.DeformationPaths.AngularFramework, Main.DeformationPaths.BodyHinge, Main.DeformationPaths.Framework, Main.DeformationPaths.FrameworkOnSurface, Main.DeformationPaths.Polytope, Main.DeformationPaths.SpherePacking, Main.DeformationPaths.SphericalDiskPacking, Main.DeformationPaths.VolumeHypergraph}}","page":"Auxiliary Methods","title":"Main.DeformationPaths.is_rigid","text":"is_rigid(F[; tol, tol, tested_random_flexes, symmetric_newton])\n\nHeuristically checks if a geometric constraint system F is (continuously) rigid. \n\n\n\n\n\n","category":"method"},{"location":"Auxiliary/#Main.DeformationPaths.is_inf_rigid-Tuple{Union{Main.DeformationPaths.AngularFramework, Main.DeformationPaths.BodyHinge, Main.DeformationPaths.Framework, Main.DeformationPaths.FrameworkOnSurface, Main.DeformationPaths.Polytope, Main.DeformationPaths.SpherePacking, Main.DeformationPaths.SphericalDiskPacking, Main.DeformationPaths.VolumeHypergraph}}","page":"Auxiliary Methods","title":"Main.DeformationPaths.is_inf_rigid","text":"is_inf_rigid(F[; tol_rank_drop])\n\nChecks if a geometric constraint system F is infinitesimally rigid.\n\n\n\n\n\n","category":"method"},{"location":"Auxiliary/#Main.DeformationPaths.is_second_order_rigid-Tuple{Union{Main.DeformationPaths.AngularFramework, Main.DeformationPaths.BodyHinge, Main.DeformationPaths.Framework, Main.DeformationPaths.FrameworkOnSurface, Main.DeformationPaths.Polytope, Main.DeformationPaths.SpherePacking, Main.DeformationPaths.SphericalDiskPacking, Main.DeformationPaths.VolumeHypergraph}}","page":"Auxiliary Methods","title":"Main.DeformationPaths.is_second_order_rigid","text":"is_second_order_rigid(F)\n\nChecks if a geometric constraint system F is second-order rigid.\n\nSee also compute_nonblocked_flex\n\n\n\n\n\n","category":"method"},{"location":"Auxiliary/#Predictor-Corrector-Methods","page":"Auxiliary Methods","title":"Predictor-Corrector Methods","text":"","category":"section"},{"location":"Auxiliary/#Main.DeformationPaths.euler_step-Tuple{Main.DeformationPaths.ConstraintSystem, Real, Vector{<:Real}, Vector{<:Real}, Main.DeformationPaths.ConstraintSystem}","page":"Auxiliary Methods","title":"Main.DeformationPaths.euler_step","text":"euler_step(G, step_size, prev_flex, point, K_n)\n\nEuler step predicting the next point along the approximate motion.\n\nReturns\n\npredicted_point::Vector{<:Real}: The next point predicted by Euler's method.\npredicted_inf_flex::Vector{<:Real}: The tangent vector predicted by Euler's method.\n\n\n\n\n\n","category":"method"},{"location":"Auxiliary/#Main.DeformationPaths.newton_correct-Tuple{Main.DeformationPaths.ConstraintSystem, Vector{<:Real}}","page":"Auxiliary Methods","title":"Main.DeformationPaths.newton_correct","text":"newton_correct(G, point[; tol, time_penalty])\n\nApply Newton's method to correct point back to the constraints in G.\n\nArguments\n\nG::ConstraintSystem: The underlying geometric constraint system.\npoint::Vector{<:Real}: The initial point that Newton's method is applied to.\ntol::Real (optional): Numerical tolerance that is used as a stopping criterion for Newton's method. Default value: 1e-13.\ntime_penalty::Real (optional): If Newton's method takes too long, we stop the iteration and throw an error. Here, \"too long\" is measured in terms of length(point)/time_penalty seconds. Default value: 2.\n\nReturns\n\nq::Vector{<:Real}: A point q such that the Euclidean norm of the evaluated equations is at most tol\n\nSee also newton_correct\n\n\n\n\n\n","category":"method"},{"location":"Auxiliary/#Main.DeformationPaths.newton_correct-Tuple{Vector{HomotopyContinuation.ModelKit.Expression}, Vector{HomotopyContinuation.ModelKit.Variable}, Matrix{HomotopyContinuation.ModelKit.Expression}, Vector{<:Real}}","page":"Auxiliary Methods","title":"Main.DeformationPaths.newton_correct","text":"newton_correct(equations, variables, jac, point[; tol, time_penalty])\n\nApply Newton's method to correct point back to the constraints in equations.\n\nArguments\n\nequations::Vector{Expression}: Equations to correct point to.\nvariables::Vector{Variable}: Variables from the affine coordinate ring.\njac::Matrix{Expression}: Jacobian matrix corresponding to equations and variables.\npoint::Vector{<:Real}: The initial point that Newton's method is applied to.\ntol::Real (optional): Numerical tolerance that is used as a stopping criterion for Newton's method. Default value: 1e-13.\ntime_penalty::Real (optional): If Newton's method takes too long, we stop the iteration and throw an error. Here, \"too long\" is measured in terms of length(point)/time_penalty seconds. Default value: 2.\n\nReturns\n\nq::Vector{<:Real}: A point q such that the Euclidean norm of the evaluated equations is at most tol\n\n\n\n\n\n","category":"method"},{"location":"Auxiliary/#Main.DeformationPaths.symmetric_newton_correct-Tuple{Main.DeformationPaths.ConstraintSystem, Vector{<:Real}}","page":"Auxiliary Methods","title":"Main.DeformationPaths.symmetric_newton_correct","text":"symmetric_newton_correct(G, point[; tol, time_penalty])\n\nApply symmetric Newton's method to correct point back to the constraints in equations.\n\nThe symmetric Newton corrector evaluates the Jacobian matrix less often.\n\nArguments\n\nG::ConstraintSystem: The underlying geometric constraint system.\npoint::Vector{<:Real}: The initial point that Newton's method is applied to.\ntol::Real (optional): Numerical tolerance that is used as a stopping criterion for Newton's method. Default value: 1e-13.\ntime_penalty::Real (optional): If Newton's method takes too long, we stop the iteration and throw an error. Here, \"too long\" is measured in terms of length(point)/time_penalty seconds. Default value: 2.\n\nReturns\n\nq::Vector{<:Real}: A point q such that the Euclidean norm of the evaluated equations is at most tol\n\nSee also symmetric_newton_correct\n\n\n\n\n\n","category":"method"},{"location":"Auxiliary/#Main.DeformationPaths.symmetric_newton_correct-Tuple{Vector{HomotopyContinuation.ModelKit.Expression}, Vector{HomotopyContinuation.ModelKit.Variable}, Matrix{HomotopyContinuation.ModelKit.Expression}, Vector{<:Real}}","page":"Auxiliary Methods","title":"Main.DeformationPaths.symmetric_newton_correct","text":"symmetric_newton_correct(equations, variables, jac, point[; tol, time_penalty])\n\nApply symmetric Newton's method to correct point back to the constraints in equations.\n\nThe symmetric Newton corrector evaluates the Jacobian matrix less often.\n\nArguments\n\nequations::Vector{Expression}: Equations to correct point to.\nvariables::Vector{Variable}: Variables from the affine coordinate ring.\njac::Matrix{Expression}: Jacobian matrix corresponding to equations and variables.\npoint::Vector{<:Real}: The initial point that Newton's method is applied to.\ntol::Real (optional): Numerical tolerance that is used as a stopping criterion for Newton's method. Default value: 1e-13.\ntime_penalty::Real (optional): If Newton's method takes too long, we stop the iteration and throw an error. Here, \"too long\" is measured in terms of length(point)/time_penalty seconds. Default value: 2.\n\nReturns\n\nq::Vector{<:Real}: A point q such that the Euclidean norm of the evaluated equations is at most tol\n\n\n\n\n\n","category":"method"},{"location":"Auxiliary/#Infinitessimal-Flexes","page":"Auxiliary Methods","title":"Infinitessimal Flexes","text":"","category":"section"},{"location":"Auxiliary/#Main.DeformationPaths.compute_nontrivial_inf_flexes-Tuple{Main.DeformationPaths.ConstraintSystem, Vector{<:Real}, Main.DeformationPaths.ConstraintSystem}","page":"Auxiliary Methods","title":"Main.DeformationPaths.compute_nontrivial_inf_flexes","text":"compute_nontrivial_inf_flexes(G, point, K_n[; tol])\n\nCompute the nontrivial infinitesimal flexes of a geometric constraint system G in point.\n\n\n\n\n\n","category":"method"},{"location":"Auxiliary/#Main.DeformationPaths.compute_nonblocked_flex-Tuple{Union{Main.DeformationPaths.AngularFramework, Main.DeformationPaths.BodyHinge, Main.DeformationPaths.Framework, Main.DeformationPaths.FrameworkOnSurface, Main.DeformationPaths.Polytope, Main.DeformationPaths.SpherePacking, Main.DeformationPaths.SphericalDiskPacking, Main.DeformationPaths.VolumeHypergraph}}","page":"Auxiliary Methods","title":"Main.DeformationPaths.compute_nonblocked_flex","text":"compute_nonblocked_flex(F[; tol_rank_drop, tol])\n\nCompute an infinitesimal flex of F that is not blocked by an equilibrium stress.\n\n\n\n\n\n","category":"method"},{"location":"Auxiliary/#Transformation-Methods","page":"Auxiliary Methods","title":"Transformation Methods","text":"","category":"section"},{"location":"Auxiliary/#Main.DeformationPaths.to_Array-Tuple{Main.DeformationPaths.ConstraintSystem, Matrix{<:Real}}","page":"Auxiliary Methods","title":"Main.DeformationPaths.to_Array","text":"to_Array(G, p)\n\nTransform a realization p to a vector of coordinates.\n\n\n\n\n\n","category":"method"},{"location":"Auxiliary/#Main.DeformationPaths.to_Array-Tuple{Union{Main.DeformationPaths.AngularFramework, Main.DeformationPaths.BodyHinge, Main.DeformationPaths.Framework, Main.DeformationPaths.FrameworkOnSurface, Main.DeformationPaths.SpherePacking, Main.DeformationPaths.SphericalDiskPacking, Main.DeformationPaths.VolumeHypergraph}, Matrix{<:Real}}","page":"Auxiliary Methods","title":"Main.DeformationPaths.to_Array","text":"to_Array(F, p)\n\nTransform a realization p to a vector of coordinates.\n\n\n\n\n\n","category":"method"},{"location":"Auxiliary/#Main.DeformationPaths.to_Array-Tuple{Main.DeformationPaths.Polytope, Matrix{<:Real}}","page":"Auxiliary Methods","title":"Main.DeformationPaths.to_Array","text":"to_Array(F, p)\n\nTransform a realization p to a vector of coordinates.\n\n\n\n\n\n","category":"method"},{"location":"Auxiliary/#Main.DeformationPaths.to_Matrix-Tuple{Main.DeformationPaths.ConstraintSystem, Vector{<:Real}}","page":"Auxiliary Methods","title":"Main.DeformationPaths.to_Matrix","text":"to_Matrix(G, q)\n\nTransform a vector of coordinates q to a realization matrix.\n\n\n\n\n\n","category":"method"},{"location":"Auxiliary/#Main.DeformationPaths.to_Matrix-Tuple{Union{Main.DeformationPaths.AngularFramework, Main.DeformationPaths.BodyHinge, Main.DeformationPaths.Framework, Main.DeformationPaths.FrameworkOnSurface, Main.DeformationPaths.Polytope, Main.DeformationPaths.SpherePacking, Main.DeformationPaths.SphericalDiskPacking, Main.DeformationPaths.VolumeHypergraph}, Vector{<:Real}}","page":"Auxiliary Methods","title":"Main.DeformationPaths.to_Matrix","text":"to_Matrix(F, q)\n\nTransform a vector of coordinates q to a realization matrix.\n\n\n\n\n\n","category":"method"},{"location":"Auxiliary/#Special-Polytope-Methods","page":"Auxiliary Methods","title":"Special Polytope Methods","text":"","category":"section"},{"location":"Auxiliary/#Main.DeformationPaths.fix_antipodals!-Tuple{Main.DeformationPaths.Polytope}","page":"Auxiliary Methods","title":"Main.DeformationPaths.fix_antipodals!","text":"fix_antipodals!(F)\n\nEntangles the antipodal points in a polytope F so that their position is constrained to antipodal points on a sphere. \n\n\n\n\n\n","category":"method"},{"location":"Auxiliary/#Main.DeformationPaths.tetrahedral_symmetry!-Tuple{Main.DeformationPaths.Polytope}","page":"Auxiliary Methods","title":"Main.DeformationPaths.tetrahedral_symmetry!","text":"tetrahedral_symmetry!(F)\n\nAdd constraints to a polytope F representing a tetrahedral symmetry. \n\n\n\n\n\n","category":"method"},{"location":"Auxiliary/#Main.DeformationPaths.triangle_shrinking-Tuple{Main.DeformationPaths.Polytope}","page":"Auxiliary Methods","title":"Main.DeformationPaths.triangle_shrinking","text":"triangle_shrinking(F)\n\nEvenly shrink the triangular facets of a given polytope and compute the nontrivial infinitesimal flexes in each step.\n\n\n\n\n\n","category":"method"},{"location":"#DeformationPaths.jl","page":"Home","title":"DeformationPaths.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A package for approximating continuous motions of geometric constraint systems using Riemannian optimization techniques and homotopy continuation.","category":"page"},{"location":"#Contents","page":"Home","title":"Contents","text":"","category":"section"},{"location":"#Usage-Guide","page":"Home","title":"Usage Guide","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"usage.md\"\n]\nDepth = 2","category":"page"},{"location":"#API-Reference","page":"Home","title":"API Reference","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"API.md\",\n    \"DeformationPath.md\", \n    \"ConstraintSystem.md\", \n    \"Visualization.md\", \n    \"Auxiliary.md\"\n]\nDepth = 2","category":"page"},{"location":"ConstraintSystems/#Constraint-System-Constructors","page":"ConstraintSystem","title":"Constraint System Constructors","text":"","category":"section"},{"location":"ConstraintSystems/#Main.DeformationPaths.ConstraintSystem","page":"ConstraintSystem","title":"Main.DeformationPaths.ConstraintSystem","text":"Class for Constructing a general constraint system.\n\nAttributes\n\nvertices::Vector{Int}: Vertices describing the geometric constraint system. They are given as a list of integers.\nvariables::Vector{Variable}: Coordinate variables representing the positions of the vertices.\nequations::Vector{Expression}: Equations corresponding to the constraint system.\nrealization::Matrix{<:Real}: Realization of the geometric constraint system satisfying the equations.\njacobian::Matrix{Expression}: Jacobian matrix for the equations and variables.\ndimension::Int: Dimension in which the geometric constraint system lives.\nxs::Union{Matrix{Variable}, Matrix{Expression}}: Matrix representing the possible realizations of a geometric constraint system.\nsystem::System: Polynomial system consisting of the equations and variables in the form of HomotopyContinuation.\npinned_vertices::Vector{Int}: Pinned vertices of the system. These vertices remain unchanged and are added as constraints. Pinning can, for instance, be used to factor out rigid motions.\n\n\n\n\n\n","category":"type"},{"location":"ConstraintSystems/#Main.DeformationPaths.ConstraintSystem-Tuple{Vector{Int64}, Vector{HomotopyContinuation.ModelKit.Variable}, Vector{HomotopyContinuation.ModelKit.Expression}, Matrix{<:Real}, Any}","page":"ConstraintSystem","title":"Main.DeformationPaths.ConstraintSystem","text":"ConstraintSystem(vertices::Vector{Int}, variables::Vector{Variable}, equations::Vector{Expression}, realization::Matrix{<:Real}, xs)\n\nConstructor of a ConstraintSystem object.\n\n\n\n\n\n","category":"method"},{"location":"ConstraintSystems/#Types-of-Geometric-Constraint-Systems","page":"ConstraintSystem","title":"Types of Geometric Constraint Systems","text":"","category":"section"},{"location":"ConstraintSystems/#Main.DeformationPaths.SpherePacking","page":"ConstraintSystem","title":"Main.DeformationPaths.SpherePacking","text":"SpherePacking([vertices,] radii, realization[; pinned_vertices])\n\nClass for sticky sphere packings.\n\n\n\n\n\n","category":"type"},{"location":"ConstraintSystems/#Main.DeformationPaths.SphericalDiskPacking","page":"ConstraintSystem","title":"Main.DeformationPaths.SphericalDiskPacking","text":"SphericalDiskPacking([vertices,] contacts, [inversive_distances,] realization[; pinned_vertices])\n\nClass for spherical disk packings in Minkowski space.\n\n\n\n\n\n","category":"type"},{"location":"ConstraintSystems/#Main.DeformationPaths.Polytope","page":"ConstraintSystem","title":"Main.DeformationPaths.Polytope","text":"Polytope([vertices,] facets, realization[; pinned_vertices])\n\nClass for 3-dimensional polytopes with edge-length and facet planarity constraints.\n\nFor the computation of the normals, we assume that the origin lies in the barycenter. Otherwise, we translate the polytope accordingly.\n\n\n\n\n\n","category":"type"},{"location":"ConstraintSystems/#Main.DeformationPaths.FrameworkOnSurface","page":"ConstraintSystem","title":"Main.DeformationPaths.FrameworkOnSurface","text":"FrameworkOnSurface([vertices,] bars, realization, surface[; pinned_vertices])\n\nClass for bar-joint frameworks constrained to a surface.\n\n\n\n\n\n","category":"type"},{"location":"ConstraintSystems/#Main.DeformationPaths.Framework","page":"ConstraintSystem","title":"Main.DeformationPaths.Framework","text":"Framework([vertices,] bars, realization[; pinned_vertices])\n\nClass for bar-joint frameworks.\n\n\n\n\n\n","category":"type"},{"location":"ConstraintSystems/#Main.DeformationPaths.VolumeHypergraph","page":"ConstraintSystem","title":"Main.DeformationPaths.VolumeHypergraph","text":"VolumeHypergraph([vertices,] volumes, realization[; pinned_vertices])\n\nClass for volume-constrained hypergraphs.\n\n\n\n\n\n","category":"type"},{"location":"ConstraintSystems/#Main.DeformationPaths.BodyHinge","page":"ConstraintSystem","title":"Main.DeformationPaths.BodyHinge","text":"BodyHinge([vertices,] facets, realization[; pinned_vertices])\n\nClass for body-hinge frameworks, which are essentially polytopes with rigid facets.\n\n\n\n\n\n","category":"type"},{"location":"ConstraintSystems/#Main.DeformationPaths.AngularFramework","page":"ConstraintSystem","title":"Main.DeformationPaths.AngularFramework","text":"AngularFramework([vertices,] angles, realization[; pinned_vertices])\n\nClass for angular bar-joint frameworks.\n\n\n\n\n\n","category":"type"},{"location":"ConstraintSystems/#Transformations","page":"ConstraintSystem","title":"Transformations","text":"","category":"section"},{"location":"ConstraintSystems/#Main.DeformationPaths.equations!","page":"ConstraintSystem","title":"Main.DeformationPaths.equations!","text":"equations!(G, equations)\n\nSet the equations of G to equations.\n\n\n\n\n\n","category":"function"},{"location":"ConstraintSystems/#Main.DeformationPaths.add_equations!","page":"ConstraintSystem","title":"Main.DeformationPaths.add_equations!","text":"add_equations!(G, equations)\n\nAdd the equations to those of G.\n\n\n\n\n\n","category":"function"},{"location":"ConstraintSystems/#Main.DeformationPaths.realization!","page":"ConstraintSystem","title":"Main.DeformationPaths.realization!","text":"realization!(G, realization)\n\nSet the realization of G to realization.\n\n\n\n\n\n","category":"function"},{"location":"API/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"API/","page":"API Reference","title":"API Reference","text":"Welcome to the API documentation.","category":"page"},{"location":"API/","page":"API Reference","title":"API Reference","text":"You can find details in the subpages:","category":"page"},{"location":"API/","page":"API Reference","title":"API Reference","text":"DeformationPath Constructors","category":"page"},{"location":"API/","page":"API Reference","title":"API Reference","text":"ConstraintSystem Constructors","category":"page"},{"location":"API/","page":"API Reference","title":"API Reference","text":"Visualization Methods","category":"page"},{"location":"API/","page":"API Reference","title":"API Reference","text":"Auxiliary Methods","category":"page"}]
}
